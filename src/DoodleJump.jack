class DoodleJump {
   field int maxHeight;

   field Doodle doodle; // the doodle of this game

   field int velocity; // the doodle's current velocity
   field int speed;  // the doodle's left/right speed

   field PlatformManager platformManager;

   field int downVelocity;

   field int score;

   /** Constructs a new Doodle Game. */
   constructor DoodleJump new() {
      // Set random seed
      do LCGRandom.setSeed(42);
      // Set max height to 55
      let maxHeight = 55;
      // Creates a 31 by 31 pixels doodle
      let doodle = Doodle.new(256, 100, 31);
      let platformManager = PlatformManager.new();

      let velocity = -5;
      let score = 0;

      do separateScreen();
      do initializeScore();
      do Sys.wait(1000);
      return this;
   }

   /** Disposes this game. */
   method void dispose() {
      do doodle.dispose();
      do Memory.deAlloc(this);
      return;
   }

   method void separateScreen() {
      do Screen.setColor(true);
      do Screen.drawRectangle(0, 0, 127, 255);
      do Screen.drawRectangle(384, 0, 511, 255);
   
      do Screen.drawRectangle(0, 12, 511, 13);
      return;
   }

   method void initializeScore() {
      do Output.moveCursor(0, 17);
      do Output.printInt(score);
      return;
   }

   // Update score and return height(negative speed for platforms to moveDown)
   method void updateScore() {
      let score = score - downVelocity;
      do Output.moveCursor(0, 17);
      do Output.printInt(score);
      return;
   }

   method boolean gameOver() {
      if (doodle.getDoodleTop() > 255) {
         do Output.printString("GAME OVER!");
         return true;
      }
      if (score < 0) {
         let score = 32767;
         do Output.moveCursor(0, 33);
         do Output.printInt(score);
         do Output.printString("GAME OVER!");
         return true;
      }
      return false;
   }

   method void movePlatformsAndUpdateScore() {
      do platformManager.movePlatforms(downVelocity);
      // if downward velocity is not 0 update scores and adjust downVelocity
      if (downVelocity < 0) {
         do updateScore();
         let downVelocity = downVelocity + 1;
      }
      return;
   }

   /** Moves the doodle in the current velocity. */
   method void moveDoodle() {
      // move doodle up by velocity subtract(add) downward velocity
      if (velocity > 0) {
         do doodle.moveUp(velocity + downVelocity);
      }
      // if velocity is negative, move doodle down
      if (velocity < 0) {
         do doodle.moveDown(velocity);
      }
      let velocity = velocity - 1;
      if (downVelocity < 0) {    // Update the velocity to 0 (make doodle still) AFTER the doodle moves up, when there is downward velocity
         let velocity = 0;
      }
      // Increase right/left speed
      do updateSpeed();
      if (speed > 0) {
         do doodle.moveRight(speed);
      }
      if (speed < 0) {
         do doodle.moveLeft(speed);
      }
      return;
   }

   method int initDownVelocity() {
      if (downVelocity = 0) {
         if ((doodle.getDoodleTop() - velocity) < maxHeight) {
            return -velocity;
         }
      }
      return downVelocity;
   }

   method void updateSpeed() {
      var char key;  // the key currently pressed by the user
      let key = Keyboard.keyPressed();
      if (key = 0) {
         let speed = 0;
      }
   
      if ((key = 130) & (speed > -8)) {  // left
         let speed = speed - 2;
      }
      if ((key = 132) & (speed < 8)) {  // right
         let speed = speed + 2;
      }

      // Adjust speed when reach left bound or right bound so that memory address would always be valid
      if ((doodle.getDoodleLeft() + speed) < 128) {
         let speed = 128 - doodle.getDoodleLeft();
      }
      if ((doodle.getDoodleRight() + speed) > 384) {
         let speed = 384 - doodle.getDoodleRight();
      }

      return;
   }

   // Check if doodle can land on any surface (platform or land), and adjust the velocity
   method boolean canLand() {
      var int nextSurfaceToLand;

      let nextSurfaceToLand = platformManager.platformToLand(doodle.getDoodleLeft() + speed, doodle.getDoodleRight() + speed, doodle.getDoodleTop() - velocity, doodle.getDoodleBottom() - velocity);
      if (nextSurfaceToLand = 256) {
         return false;
      }
      let velocity = doodle.getDoodleBottom() - nextSurfaceToLand + 1;
      return true;
   }

   // Jump!!
   method void jump() {
      let velocity = 15;
      do Sys.wait(10);
      return;
   }

   method void run() {
      var boolean landed;
      var boolean gameOver;
      let gameOver = false;

      while (~gameOver) {
         do movePlatformsAndUpdateScore();
         if (velocity < 0) {
            let landed = canLand();
            do moveDoodle();
            do platformManager.collideAndReconstruct(doodle.getDoodleLeft(), doodle.getDoodleRight(), doodle.getDoodleTop(), doodle.getDoodleBottom());
            if (landed) {
               do jump();
            }
         } else {
            // Check if reach max height, if so, set a downward velocity
            let downVelocity = initDownVelocity();
            do platformManager.generateRandomPlatform();
            do platformManager.collideAndReconstruct(doodle.getDoodleLeft(), doodle.getDoodleRight(), doodle.getDoodleTop(), doodle.getDoodleBottom());
            do doodle.draw();
            do moveDoodle();
            do platformManager.collideAndReconstruct(doodle.getDoodleLeft(), doodle.getDoodleRight(), doodle.getDoodleTop(), doodle.getDoodleBottom());
         }
         // Wait 30 clock cycles to let animation show properly
         do Sys.wait(30);
         let gameOver = gameOver();
      } // while
      return;
   }

   method int getScore() {
      return score;
   }
}



